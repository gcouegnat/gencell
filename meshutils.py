
import numpy as np

def medit_write(filename, vertices, cells, ids=None):
    """Write a mesh to Medit format

        
    
    
    """
    f = open(filename, "w")
    f.write("MeshVersionFormatted 1\n")
    f.write("Dimension\n2\n")
    f.write("Vertices\n%d\n" % vertices.shape[0])
    for v in vertices:
        f.write("%f\t%f\t%d\n" % (v[0], v[1], 0))
    f.write("Triangles\n%d\n" % cells.shape[0])
    if ids is None:
        ids = np.zeros((len(cells)))
    for c, m in zip(cells, ids):
        f.write("%d\t%d\t%d\t%d\n" % (c[0] + 1, c[1] + 1, c[2] + 1, m))
    f.write("End")
    f.close()


def vtk_write(filename, vertices, cells, ids=None, point_data=None, cell_data=None):
    f = open(filename, "w")
    f.write("# vtk DataFile Version 3.0\n")
    f.write("Generated by meshutils\n")
    f.write("ASCII\n")
    f.write("DATASET UNSTRUCTURED_GRID\n")
    f.write("POINTS %d float\n" % len(vertices))
    for vertex in vertices:
        f.write("%f %f %f\n" % (vertex[0], vertex[1], 0.0))
    f.write("CELLS %d %d\n" % (len(cells), 4 * len(cells)))
    for cell in cells:
        f.write("3 %s %s %s\n" % (cell[0], cell[1], cell[2]))
    f.write("CELL_TYPES %d\n" % len(cells))
    for _ in xrange(len(cells)):
        f.write("%d\n" % 5)
    if ids is not None or cell_data is not None:
        f.write("CELL_DATA %s\n" % len(cells))
    if ids is not None:
        f.write("SCALARS marker int 1\n")
        f.write("LOOKUP_TABLE default\n")
        for mark in ids:
            f.write("%s\n" % mark)
    if cell_data is not None:
        for key, data in cell_data.items():
            f.write("SCALARS %s float 1\n" % key)
            f.write("LOOKUP_TABLE default\n")
            for value in data:
                f.write("%s\n" % value)
    if point_data is not None:
        f.write("POINT_DATA %d\n" % len(vertices))
        for key, data in point_data.items():
            f.write("SCALARS %s float 3\n" % key)
            f.write("LOOKUP_TABLE default\n")
            for i in xrange(len(vertices)):
                f.write("%f %f %f\n" % (data[2*i], data[2*i+1], 0))
    f.close()


def gnuplot_write(filename, vertices, cells, ids):
    f = open(filename, "w")
    for points in cells:
        for pt in points:
            f.write("%f %f\n" % tuple(vertices[pt]))
        f.write("%f %f\n\n" % tuple(vertices[points[0]]))
    f.close()


def pdf_write(filename, vertices, cells, ids):

    import matplotlib.pyplot as plt

    fig = plt.figure()
    for points in cells:
        plt.fill(vertices[points, 0], vertices[points, 1], facecolor='0.9',
                 edgecolor='k')
        plt.gca().set_aspect('equal')
    plt.gca().set_axis_off()
    fig.savefig(filename)


class MeshBase():
    def __init__(self):
        self.vertices = None
        self.cells = None
        self.cell_markers = None

    def set_vertices(self, vertices):
        self.vertices = np.array(vertices, dtype="float")
        for i, vertex in enumerate(vertices):
            self.vertices[i] = vertex

    def set_cells(self, cells, markers=None):
        if markers is not None:
            assert(len(markers) == len(cells))

        self.cells = np.array(cells, dtype="int")
        for i, cell in enumerate(cells):
            self.cells[i] = cell

        if markers is not None:
            self.set_cell_markers(markers)

    def set_cell_markers(self, markers):
        assert(len(markers) == len(self.cells))
        self.cell_markers = np.array(markers, dtype="int")
        for i, mark in enumerate(markers):
            self.cell_markers[i] = mark

    def save(self, filename):
        ext = filename.split(".")[-1]
        if ext == "mesh":
            medit_write(filename, self.vertices, self.cells,
                        self.cell_markers)
        elif ext == "vtk":
            vtk_write(filename, self.vertices, self.cells,
                      self.cell_markers)
        elif ext == "gnu":
            gnuplot_write(filename, self.vertices, self.cells,
                          self.cell_markers)
        elif ext == "pdf":
            pdf_write(filename, self.vertices, self.cells,
                      self.cell_markers)
        else:
            raise ValueError, "Unknown mesh type: %s" % ext

    def renumber_cell_markers(self, reverse=False):
        unique_markers, indices = np.unique(self.cell_markers,
                                            return_inverse=True)
        if reverse:
            num_unique_markers = len(unique_markers) - 1
            self.cell_markers = num_unique_markers - indices
        else:
            self.cell_markers = indices

    def remove_cells_with_marker(self, marker):
        old_vertices = self.vertices
        old_cells = self.cells
        old_ids = self.cell_markers

        num_old_cells = old_cells.shape[0]
        num_old_vertices = old_vertices.shape[0]

        renum = -1 * np.ones(num_old_vertices)

        for k in range(num_old_cells):
            if old_ids[k] != marker:
                renum[old_cells[k, 0:3]] = 1

        num_vert = 0
        for k in range(num_old_vertices):
            if renum[k] > -1:
                renum[k] = num_vert
                num_vert += 1

        new_vertices = old_vertices[renum > -1]
        new_cells = old_cells[old_ids != marker]
        for k in range(new_cells.shape[0]):
            new_cells[k, 0:3] = renum[new_cells[k, 0:3]]

        new_ids = old_ids[old_ids != marker]

        self.set_vertices(new_vertices)
        self.set_cells(new_cells)
        self.set_cell_markers(new_ids)


def medit_reader(filename):

    def get_next_line(stream, comment="#"):
        while 1:
            next_line = stream.readline()
            if not next_line:
                return None
            elif next_line.strip().startswith(comment) or len(next_line.strip()) == 0:
                pass
            else:
                return next_line.strip()

    f = open(filename, 'r')

    vertices = []
    cells = []
    cell_markers = []

    while True:
        next_line = get_next_line(f)
        if not next_line:
            break

        if next_line.startswith('Dimension'):
            if len(next_line.split()) > 1:
                dim = int(next_line[1])
            else:
                dim = int(get_next_line(f).split()[0])

        if next_line.startswith('Vertices'):
            if len(next_line.split()) > 1:
                num_vertex = int(next_line[1])
            else:
                num_vertex = int(get_next_line(f).split()[0])
            for i in range(num_vertex):
                next_line = get_next_line(f)
                vertices.append([float(coord) for coord in next_line.split()[0:dim]])

        if next_line.startswith('Triangles'):
            if len(next_line.split()) > 1:
                num_cell = int(next_line[1])
            else:
                num_cell = int(get_next_line(f).split()[0])
            for i in range(num_cell):
                next_line = get_next_line(f)
                cells.append([int(coord) - 1 for coord in next_line.split()[0:3]])
                cell_markers.append(int(next_line.split()[3]))

    #print 'Dimension: %d' % dim
    #print 'Number of vertex: %d' % num_vertex
    #print 'Number of cell: %d' % num_cell

    mesh = MeshBase()
    mesh.set_vertices(vertices)
    mesh.set_cells(cells)
    mesh.set_cell_markers(cell_markers)

    return mesh


def read_mesh(filename):
    ext = filename.split('.')[-1]
    if ext == 'mesh':
        return medit_reader(filename)
    else:
        raise ValueError, "Unknown mesh type: %s" % ext


if __name__ == "__main__":

    v = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]
    c = [(0, 1, 2), (0, 2, 3)]
    m = [100, 10]

    mesh = MeshBase()
    mesh.set_vertices(v)
    mesh.set_cells(c, m)
    mesh.save("test.mesh")

    mesh.renumber_cell_markers(reverse=True)
    mesh.remove_cells_with_marker(0)
    mesh.save("test.vtk")
